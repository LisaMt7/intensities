(()=>{var euclidean=(v1,v2)=>Math.sqrt(v1*v1+v2*v2);var add=vec=>vec.reduce((a,b)=>a+b,0);var average=vec=>add(vec)/vec.length;var getAverage=(arr1,arr2,method="euclidean")=>{return average(arr1.map((nestedArr,i)=>{return average(nestedArr.map((val,j)=>{if(method==="euclidean")return euclidean(val,arr2[i][j]);else return euclidean(val,arr2[i][j])}))}))};var mapNestedArray=(nested,arrays,iterators=[],func)=>{return nested.map((v,j)=>{const newIterators=[...iterators,j];if(Array.isArray(v))return mapNestedArray(v,arrays,newIterators,func);else return func(newIterators)})};var average2=(...arrays)=>{return get(iterators=>{return arrays.reduce((a,arr2)=>a=a+iterators.reduce((a2,b)=>a2[b],arr2),0)/arrays.length},arrays)};function get(func,arrays){return arrays[0].map((nestedArr,i)=>{return mapNestedArray(nestedArr,arrays,[i],func)})}function shuffle(array){let currentIndex=array.length,randomIndex;while(currentIndex!=0){randomIndex=Math.floor(Math.random()*currentIndex);currentIndex--;[array[currentIndex],array[randomIndex]]=[array[randomIndex],array[currentIndex]]}return array}var shuffle_default=shuffle;onmessage=async function(e){const[msg,...args]=e.data;let res;if(msg==="process"){res=await process(...args)}else{console.error("Unrecognized message in worker",msg)}postMessage(["done",res])};var getAverageDistance=(box1,box2)=>{const distance1=getAverage(box1[0],box2[0]);const distance2=getAverage(box1[1],box2[1]);const aveDist=(distance1+distance2)/2;return aveDist};var createInfo=(data,{id,time,timeInSeconds,i,bin,instances,history,start,end,features}={})=>{time=time??{t:timeInSeconds,i};const pattern={id:id??Math.floor(1e5*Math.random()),time,instances,bin,data,original:data,history:history??[],start,end,features:features??data};if(!instances)pattern.instances=[{info:pattern}];if(pattern.history.length===0)pattern.history.push(data);return pattern};var getUpdate=(base,patterns,{maxDist,freqBin,startTime,bin,start,end})=>{let features=base?.features??base?.slice??base;if(base.slice)base=base.slice;const original=base;const hasInfo=!!original.data;if(base.data)base=base.data;const timeInSeconds=(Date.now()-startTime)/1e3;const matches=[];const leftover=patterns.filter(o=>{if(!o.data)o=createInfo(o.slice??o,{i:o?.bin,start,end,bin:freqBin,features:o?.features});const dist=getAverageDistance(features,o.features);if(dist<maxDist){matches.push({distance:dist,info:o})}else return true});const pattern=hasInfo?original:createInfo(base,{timeInSeconds,i:bin,bin:freqBin,start,end,features});if(matches.length>0)pattern.instances.push(...matches.map(o=>o.info.instances).flat());return{pattern,leftover}};var getFeatures=data=>{const mapped=data.map(o=>o.slice);const features=mapped;return features};async function process(arr,info){if(!info.startTime)info.startTime=Date.now();info.changed=false;const people=arr.length;let patterns=0;const isArrays=!!arr[0].frequencies[0]?.length;if(!isArrays)arr.forEach(o=>o.frequencies=[o.frequencies]);const firstPersonFreqs=arr[0].frequencies;info.frequencies=firstPersonFreqs[0].length;let historySlices=[];firstPersonFreqs.forEach((_,i)=>{if(info.history[0].length===info.duration){historySlices.push(Object.assign({},info.history));info.history.forEach(histArr=>histArr.shift())}arr.map(o=>o.frequencies[i]).forEach((frequencies,person)=>{if(!info.history[person])info.history[person]=[];info.history[person].push(frequencies)})});if(info.shuffle)historySlices=shuffle_default(historySlices);const freqBins=info.freqWindow?Array.from({length:Math.ceil(info.frequencies/info.freqWindow)},(e,i)=>i*info.freqWindow):[0];const promises=freqBins.forEach((freqBin,i)=>{const start=freqBin;let end=freqBin+(info.freqWindow??info.frequencies);if(end>info.frequencies)end=info.frequencies;const compareSelf=array=>{let patterns2=[];const get2=arr2=>{const o=arr2[0];return getUpdate(o,arr2.slice(1),{maxDist:info.distanceMax,freqBin,startTime:info.startTime,bin:o.bin,start,end})};let leftover=array;do{const tic=performance.now();const update=get2(leftover);if(update.pattern)patterns2.push(update.pattern);leftover=update.leftover;const toc=performance.now();const ratio=(array.length-leftover.length)/array.length;postMessage(["progress",ratio,toc-tic,patterns2.length])}while(leftover.length>0);return patterns2};const match=array=>{const matches=compareSelf(array);return matches.map(o=>{if(o.instances.length>1){o.data=average2(...o.instances.map(o2=>o2.info.data));o.features=average2(...o.instances.map(o2=>o2.info.features));o.history.push(o.data)}return o})};let toCompare=historySlices.map((slice,i2)=>{return{slice:Array.from({length:people}).map((_,i3)=>slice[i3].map(xSlice=>Array.from(xSlice).slice(start,end))),bin:i2}});console.log("toCompare",toCompare);const features=getFeatures(toCompare);features.forEach((o,i2)=>toCompare[i2].features=o);let prevMatchCount=null;do{prevMatchCount=toCompare.length;toCompare=match(toCompare)}while(toCompare.length!=prevMatchCount);const finalMatches=toCompare;console.log("Final Matches",finalMatches,finalMatches.reduce((a,b)=>a+b.instances.length,0));finalMatches.forEach(o=>{if(!info.alphabet.has(o.id))patterns++;info.alphabet.set(o.id,o.instances.length);info.alphabetData.set(o.id,o);info.changed=true})});return info}})();
